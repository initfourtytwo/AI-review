# Week 2 — Build a Multi-Modal Chatbot: LLMs, Gradio UI, and Agents in Action

## 🧭 목차

1. [Gradio를 활용한 빠른 UI 프로토타이핑](#gradio를-활용한-빠른-ui-프로토타이핑)
2. [챗봇, 컨텍스트, 멀티샷 프롬프트](#챗봇-컨텍스트-멀티샷-프롬프트)
3. [도구와 함수 호출(Function Calling)](#도구와-함수-호출function-calling)
4. [에이전트와 멀티모달 어시스턴트](#에이전트와-멀티모달-어시스턴트)
5. [핵심 요약](#핵심-요약)
6. [코드](#코드)

---

## Gradio를 활용한 빠른 UI 프로토타이핑

* **목적:** 몇 줄의 코드로 LLM 기반 인터페이스를 구축하기.

* **핵심 패턴:**

  ```python
  import gradio as gr
  def greet(name): return f"Hello, {name}!"
  gr.Interface(fn=greet, inputs="text", outputs="text").launch()
  ```

---

## 챗봇, 컨텍스트, 멀티샷 프롬프트

* **목표:** Gradio의 `ChatInterface`로 고객지원용 챗봇 구현
* **대화 메모리:** 실제로는 **매 요청마다 전체 히스토리 재전송**, 내부 기억 없음
* **프롬프트 전략:**

  * **System message**: 에이전트 성격·역할 정의 (“친절한 세일즈 어시스턴트”)
  * **One-shot / Multi-shot 예시**: 어조와 답변 예시 제공으로 스타일 고정
* **동적 컨텍스트 주입:**

  * 특정 키워드(예: “벨트”) 감지 → 관련 정보 system prompt로 추가
  * 미니 RAG처럼 작동, 런타임에 외부 지식 삽입
* **핵심 교훈:**
  컨텍스트 = 기존 대화 히스토리 + 시스템 규칙 + 동적으로 추가된 정보

---

## 도구와 함수 호출(Function Calling)

* **정의:** LLM이 외부 함수를 직접 호출해 **데이터나 계산**을 수행할 수 있는 기능

* **작동 방식:**

  1. Python 함수 정의 (`get_ticket_price(city)`)
  2. JSON 스키마로 설명 (`tools=[{name, description, parameters}]`)
  3. API 호출 시 `tools` 인자로 전달
  4. 모델이 도구 호출 요청 시, 함수를 실행하고 `"tool"` 메시지로 결과 반환

* **예시:** 항공권 가격을 조회하는 `get_ticket_price()` 함수 호출

* **핵심 개념:**
  컨텍스트 주입과 유사하게, LLM은 “요청 → 함수 실행 → 결과 반영” 루프를 수행

---

## 에이전트와 멀티모달 어시스턴트

* **정의:** 특정 역할(이미지 생성, 음성 변환 등)을 수행하는 **자율적 모듈**
* **구현된 에이전트:**

  * **Artist agent**: DALL·E 3을 이용해 목적지 이미지를 생성
  * **Talker agent**: TTS(Text-to-Speech)로 응답을 음성으로 읽기
* **통합 구조:**

  * 채팅 로직 확장 → 툴 호출 시 artist·talker 병행 실행
* **프레임워크 개념:**

  * **Tools** = 단순 함수
  * **Agents** = 함수 + 목적 + 자율성 + 멀티모달 능력
  * 이들의 결합 = **멀티모달 에이전틱 AI 시스템**

---

## 핵심 요약

* **API 구조는 거의 동일**하며 문법 차이만 있음
* **Gradio**로 빠르고 직관적인 프로토타이핑 가능
* 챗봇의 "기억"은 실제 메모리가 아닌 전체 대화 재전송 방식
* 도구(Function Call)는 행동 가능한 모델의 핵심 구성요소
* **에이전트**는 여러 모델과 모달리티를 연결하는 고도화된 형태
* 실습 흐름: **API → UI → 챗봇 → 툴 → 에이전트 앱**

---

## 코드

<details>
<summary>코드 보기</summary>

```python
# ============================================================
# 🧠 Week 2 — 주요 코드 패턴
# ============================================================

# (1) Multi-Model API Calls
# OpenAI, Anthropic, Gemini의 공통 호출 구조
messages = [{"role":"system","content":"You are a witty assistant."},
            {"role":"user","content":"Tell a data-science joke."}]
resp = client.chat.completions.create(model="gpt-4o-mini", messages=messages)
print(resp.choices[0].message.content)

# ------------------------------------------------------------

# (2) Gradio UI Wrapper
# 최소한의 코드로 LLM UI 구축
import gradio as gr
def message_gpt(prompt):
    msgs=[{"role":"system","content":"You are helpful."},
          {"role":"user","content":prompt}]
    return client.chat.completions.create(model="gpt-4o-mini", messages=msgs)\
                .choices[0].message.content
gr.Interface(fn=message_gpt, inputs="text", outputs="markdown").launch()

# ------------------------------------------------------------

# (3) Streaming Generator
# 스트리밍 방식으로 실시간 결과 표시
def stream_gpt(prompt):
    msgs=[{"role":"system","content":"Helpful assistant."},
          {"role":"user","content":prompt}]
    result=""
    for chunk in client.chat.completions.create(
            model="gpt-4o-mini", messages=msgs, stream=True):
        if chunk.choices[0].delta.content:
            result += chunk.choices[0].delta.content
            yield result

# ------------------------------------------------------------

# (4) Tool Integration
# 항공권 가격 조회 예시
def get_ticket_price(city):
    prices={"london":799,"paris":899,"tokyo":1400,"berlin":499}
    return prices.get(city.lower(),"unknown")

tools=[{
  "type":"function",
  "function":{
    "name":"get_ticket_price",
    "description":"Return ticket price for a city.",
    "parameters":{"type":"object",
      "properties":{"destination_city":{"type":"string"}},
      "required":["destination_city"]}
}}]

# 툴 접근이 가능한 모델 호출
resp = client.chat.completions.create(
    model="gpt-4o-mini", messages=messages, tools=tools)

# ------------------------------------------------------------

# (5) Agentic Extension
# 이미지 + 음성 에이전트 통합
def artist(city):
    return openai.images.generate(model="dall-e-3",
        prompt=f"Scenic view of {city} for airline brochure.",
        size="512x512").data[0].b64_json

def talker(text):
    speech = openai.audio.speech.create(model="gpt-4o-mini-tts", input=text)
    with open("speech.mp3","wb") as f: f.write(speech.audio)

# 통합 에이전트: 채팅 + 이미지 + 음성
def chat_agent(prompt, history=[]):
    reply = message_gpt(prompt)
    talker(reply)
    if "to" in prompt.lower(): artist(prompt.split("to")[-1].strip())
    return reply

# ============================================================
```

</details>
